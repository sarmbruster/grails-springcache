<html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
        <title>4. Content Caching</title>
        <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen" title="Ref" charset="utf-8"/>
    </head>
    <body class="body">
    <h1><a name="4. Content Caching">4. Content Caching</a></h1>The <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations can be applied to controller actions and the plugin will then cache the page fragment generated by the controller whether this is done by rendering a GSP, using a <em class="italic">MarkupBuilder</em> closure, rendering text directly or whatever. Only successful page renders are cached, so redirects, 404s, errors and so on will not be.<p class="paragraph"/>Composing pages so that they can be optimally cached requires some thought. The plugin uses a servlet filter that runs 'inside' the SiteMesh filter provided by Grails. This means that cached output is decorated by SiteMesh and the resulting page can therefore contain uncached content from the SiteMesh template. In addition you can use caching at a modular level to cache the output of controller actions invoked using the <code>g:include</code> tag, or by caching taglib tags. Combining these techniques leads to powerful modular page caching. For example, you can cache the output of the 'main' controller then use <code>g:include</code> tags, or taglib tags, in the SiteMesh layout to include content on the page that is cached separately - and can be flushed separately - from the main body of the page.
<h2><a name="4.1. Caching and Flushing with Controller Actions">4.1. Caching and Flushing with Controller Actions</a></h2><h3>Example: caching Grails CRUD pages</h3><p class="paragraph"/>Grails' standard scaffolded <em class="italic">CRUD</em> pages provide a good example of how caching and flushing can be applied. For example, let's take an <em class="italic">Album</em> domain class. The scaffolded controller could be annotated like this:<p class="paragraph"/><h4>AlbumController.groovy</h4><p class="paragraph"/><div class="code"><pre>class AlbumController &#123;
    // the index action is uncached as it just performs a redirect to list
    def index = &#123;
        redirect(action: <span class="java&#45;quote">"list"</span>, params: params)
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def list = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def create = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"artistControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def save = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def show = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
    def edit = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def update = &#123;
        // standard Grails scaffolding code omitted
    &#125;<p class="paragraph"/>    @CacheFlush(&#91;<span class="java&#45;quote">"albumControllerCache"</span>, <span class="java&#45;quote">"artistControllerCache"</span>, <span class="java&#45;quote">"latestControllerCache"</span>, <span class="java&#45;quote">"popularControllerCache"</span>&#93;)
    def delete = &#123;
        // standard Grails scaffolding code omitted
    &#125;
&#125;</pre></div><p class="paragraph"/>The <em class="italic">list, show, create</em> and <em class="italic">edit</em> pages are all cached. The <em class="italic">show</em> and <em class="italic">edit</em> rely on an domain object id parameter and this will be included in the cache key so that <code>/album/show/1</code> and <code>/album/show/2</code> are cached separately. The <em class="italic">save, update</em> and <em class="italic">delete</em> actions will flush caches. Note that in addition to flushing the cache used by the <em class="italic">list, show, create</em> and <em class="italic">edit</em> actions they are flushing other caches which are content caches for controllers whose output should be refreshed if <code>Album</code> data changes.
<h2><a name="4.2. Content Caching and SiteMesh">4.2. Content Caching and SiteMesh</a></h2><h3>Example: decorating a cached page with dynamic content using SiteMesh</h3><p class="paragraph"/>It is often necessary to have portions of a page be dynamic. A typical example is when something is displayed to logged in users that will be different for each user. Those sorts of page sections are not really candidates for caching. At the same time other parts of the page may well be able to take advantage of caching. For example, if you want to display a <em class="italic">"Welcome back $username"</em> type message in page headers while caching the main body of the page you can use SiteMesh templates like this:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render a <span class="java&#45;quote">"welcome back"</span> header (tags used here are from the Spring Security plugin) &#45;&#45;%&#62;
        &#60;g:isLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loggedInUser"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"auth.loggedInAs"</span> args=<span class="java&#45;quote">"&#91;loggedInUsername()&#93;"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Logged in as &#123;0&#125;"</span>/&#62;&#60;/div&#62;
        &#60;/g:isLoggedIn&#62;
        &#60;g:isNotLoggedIn&#62;
            &#60;div id=<span class="java&#45;quote">"loginLink"</span>&#62;&#60;g:link controller=<span class="java&#45;quote">"login"</span>&#62;&#60;g:message code=<span class="java&#45;quote">"<span class="java&#45;keyword">default</span>.login.label"</span> <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Login here"</span>/&#62;&#60;/g:link&#62;&#60;/div&#62;
        &#60;/g:isNotLoggedIn&#62;<p class="paragraph"/>        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>If the controller action invoked uses <code>&#64;Cacheable</code> everything will work fine because the content of the SiteMesh layout is <em class="italic">not</em> cached - only the content generated by the cached action. The SiteMesh template is applied to cached and uncached content alike so the correct username will be displayed to your users even though the main body of the page may have been loaded from a cache.<p class="paragraph"/><h3>Example: a modular page using multiple cached sections</h3><p class="paragraph"/>One of the most powerful features of page fragment caching is that the generated page can be composed from multiple cached sections. This is accomplished using Grails' <code>g:include</code> tag. For example, in this page the main body of the page is rendered by some controller action and the output of other controllers are included in the SiteMesh layout using the <code>g:include</code> tag:<p class="paragraph"/><h4>grails-app/views/layouts/main.gsp</h4><p class="paragraph"/><div class="code"><pre>&#60;html&#62;
    &#60;head&#62;
        &#60;title&#62;&#60;g:layoutTitle <span class="java&#45;keyword">default</span>=<span class="java&#45;quote">"Welcome to My Grails Application"</span>/&#62;&#60;/title&#62;
        &#60;%&#45;&#45; render the page head from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutHead/&#62;
    &#60;/head&#62;
    &#60;body&#62;
        &#60;%&#45;&#45; render the page body from the controller &#45; may be cached &#45;&#45;%&#62;
        &#60;g:layoutBody/&#62;<p class="paragraph"/>        &#60;div class=<span class="java&#45;quote">"sidebar"</span>&#62;
            &#60;%&#45;&#45; each of these controller actions can be cached separately as well &#45;&#45;%&#62;
            &#60;g:include controller=<span class="java&#45;quote">"latest"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
            &#60;g:include controller=<span class="java&#45;quote">"popular"</span> action=<span class="java&#45;quote">"albums"</span>/&#62;
        &#60;/div&#62;
    &#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"latestAlbums"</span>)
def albums = &#123;
    def albums = Album.list(sort: <span class="java&#45;quote">"dateCreated"</span>, order: <span class="java&#45;quote">"desc"</span>, max: 10)
    &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/><h4>LatestController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"popularAlbums"</span>)
def albums = &#123;
    def albums = Album.listOrderByAverageRating(max: 10)
    <span class="java&#45;keyword">return</span> &#91;albumInstanceList: albums&#93;
&#125;</pre></div><p class="paragraph"/>If all the caches are hit the final rendered page will be composed of 3 separate cached sections. What is more, each individual section can be flushed without affecting the others so with some thought about how to compose your page and apply your caches you can optimise cache usage without delivering stale data to the user.
<h2><a name="4.3. Using Annotations at Class Level">4.3. Using Annotations at Class Level</a></h2>The <code>&#64;Cacheable</code> and <code>&#64;CacheFlush</code> annotations can be applied to controllers at class level. This is more likely useful with <code>&#64;Cacheable</code> but it is certainly possible to apply <code>&#64;CacheFlush</code> at class level so that any action on that controller will flush a set of caches. Any annotation on an individual action will be applied in preference to an annotation at class level, so a class level annotation behaves like a default. An annotation at class level will work with dynamic scaffolded actions so you don't have to generate a concrete action in order to benefit from caching behaviour.<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"albumControllerCache"</span>)
class AlbumController &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> scaffold = <span class="java&#45;keyword">true</span> // all dynamically scaffolded actions will be cached<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"albumListCache"</span>)
    def list = &#123;
        // &#8230;
    &#125;<p class="paragraph"/>    @CacheFlush(/album&#119;+Cache/)
    def save = &#123;
        // &#8230;
    &#125;<p class="paragraph"/>    def show = &#123;
        // &#8230;
    &#125;
&#125;</pre></div><p class="paragraph"/>In this example:
<ul class="star">
<li>The <em class="italic">show</em> action will use the default class level <code>&#64;Cacheable</code> annotation and its page fragment will be cached in the <em class="italic">albumControllerCache</em> cache.</li>
<li>The <em class="italic">list</em> action will not use the default as it specifies its own <code>&#64;Cacheable</code> annotation and its content will be cached separately.</li>
<li>The <em class="italic">save</em> action uses a <code>&#64;CacheFlush</code> and will therefore not be cached at all.</li>
<li>Dynamically scaffolded actions (e.g. <em class="italic">edit_, _update_, etc.) will use the class level annotation and their results will be cached in the _albumControllerCache</em> cache.</li>
</ul><p class="paragraph"/><h2><a name="4.4. Cache Headers">4.4. Cache Headers</a></h2>Content caching in the Springcache plugin attempts to respect any cache-control headers present in the original response.
Specifically the plugin will handle certain response headers as follows:<p class="paragraph"/><h4>Cache-Control: no-cache</h4><p class="paragraph"/>If this header is present in the response the content will <em class="italic">not</em> be cached even if there is a <code>&#64;Cacheable</code> annotation
present on the controller or action. This allows you to prevent caching in certain circumstances or override the
controller-wide caching policy in a particular action.<p class="paragraph"/><h4>Cache-Control: max-age=x</h4><p class="paragraph"/>If the response is cached the time-to-live of the cache entry is set so that it corresponds to the max-age value in
the <code>Cache-Control</code> header. If no such header is present the cache's configured time-to-live is used (see <a href="../guide/single.html#7. Cache Configuration" class="guide">Cache Configuration</a>).<p class="paragraph"/><h4>ETag</h4><p class="paragraph"/>If the original response set an <code>ETag</code> header <em class="italic">Springcache</em> will set the same header if it serves the response from the
cache.
Additionally, if an incoming request has an <code>If-None-Match</code> header that matches the <code>ETag</code> of the cached response <em class="italic">Springcache</em> will send a <code>304 Not Modified</code> status code and an empty response body instead of the cached response.<p class="paragraph"/><h4>Last-Modified</h4><p class="paragraph"/>If the original response set a <code>Last-Modified</code> header <em class="italic">Springcache</em> will set the same header if it serves the response
from the cache.
Additionally, if an incoming request has an <code>If-Modified-Since</code> header with a timestamp later than the
<code>Last-Modified</code> header of the cached response <em class="italic">Springcache</em> will send a <code>304 Not Modified</code> status code and an empty
response body instead of the cached response.<p class="paragraph"/><h2>The Cache Headers Plugin</h2><p class="paragraph"/>The <em class="italic">Springcache</em> plugin integrates well with the <a href="http://grails.org/plugin/cache-headers" target="blank">Cache Headers</a> plugin. Some examples:<p class="paragraph"/><h3>Preventing caching</h3><p class="paragraph"/>If you want to prevent <em class="italic">Springcache</em> from caching a response in certain circumstances:<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
def myAction = &#123;
	// &#8230;
	<span class="java&#45;keyword">if</span> (someConditionHoldsThatMeansThisShouldNotGetCached) &#123;
		cache <span class="java&#45;keyword">false</span>
	&#125;
	// &#8230;
&#125;</pre></div><p class="paragraph"/>Alternatively you might want to declare <code>&#64;Cacheable</code> at the class level and then exclude a particular action from the
cache:<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
class MyController &#123;<p class="paragraph"/>	// ...<p class="paragraph"/>	def myAction = &#123;
		cache <span class="java&#45;keyword">false</span>
		// &#8230;
	&#125;</pre></div><p class="paragraph"/><h3>Controlling cache expiry</h3><p class="paragraph"/>As explained above cache time-to-live will respect the max-age in a cache control header.<p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
def myAction = &#123;
	cache validFor: 3600
	// &#8230;
&#125;</pre></div><p class="paragraph"/>In this example the response will be cached with a time-to-live of one hour <em class="italic">regardless</em> of the default time-to-live
configured on the cache itself.<p class="paragraph"/><h3>Sending Not-Modified responses</h3><p class="paragraph"/><div class="code"><pre>@Cacheable(<span class="java&#45;quote">"myCache"</span>)
def show = &#123;
	withCacheHeaders &#123;
		def book = Book.get(params.id)
		etag &#123;
			<span class="java&#45;quote">"$&#123;book.ident()&#125;:$&#123;book.version&#125;"</span>
		&#125;
		lastModified &#123;
			book.dateCreated ?: book.dateUpdated
		&#125;
		generate &#123;
			render view: <span class="java&#45;quote">"show"</span>, model: &#91;item: book&#93;
		&#125;
	&#125;
&#125;</pre></div><p class="paragraph"/>In this example the response will be cached and any subsequent requests that send matching <code>If-Modified-Since</code> and/or
<code>If-None-Match</code> headers will be sent a <code>304 Not Modified</code> response if they hit the cache.
<h2><a name="4.5. Content Cache Keys">4.5. Content Cache Keys</a></h2>The Springcache plugin uses an instance of the interface <code>grails.plugin.springcache.key.KeyGenerator</code> to generate the cache key. The default implementation is a bean named <em class="italic">springcacheDefaultKeyGenerator</em> which is of type <code>grails.plugin.springcache.web.key.DefaultKeyGenerator</code>. If you want to use a different key generator for a particular action you just need to add the <code>keyGenerator</code> element to the <code>&#64;Cacheable</code> annotation specifying the name of a Spring bean that implements the <code>KeyGenerator</code> interface.<p class="paragraph"/><div class="code"><pre>@Cacheable(cache = <span class="java&#45;quote">"albumControllerCache"</span>, keyGenerator = <span class="java&#45;quote">"myKeyGenerator"</span>)
def list = &#123;
    // &#8230;
&#125;</pre></div><p class="paragraph"/>Alternatively you can override the default key generator by redefining the <em class="italic">springcacheDefaultKeyGenerator</em> bean in _resources.groovy_.<p class="paragraph"/><blockquote class="note">
The <code>keyGenerator</code> element is only for content caching and just works on controllers, it is ignored by the <code>&#64;Cacheable</code> annotation on service methods and taglibs.
</blockquote><p class="paragraph"/><h3><code>grails.plugin.springcache.web.key.DefaultKeyGenerator</code></h3><p class="paragraph"/>The <code>DefaultKeyGenerator</code> generates a key based on the controller name, action name and any request parameters (which can be from a query string, <em class="italic">POST</em> body or those added by Grails URL mappings, e.g. the <em class="italic">id</em> parameter on a standard <em class="italic">show</em> or <em class="italic">edit</em> action).<p class="paragraph"/><h3><code>grails.plugin.springcache.web.key.WebContentKeyGenerator</code></h3><p class="paragraph"/><code>WebContentKeyGenerator</code> is a multi-purpose <code>KeyGenerator</code> implementation that exposes a number of boolean properties that control key generation. All the properties default to <em class="italic">false_.<p class="paragraph"/><h5>ajax</h5><p class="paragraph"/>If _true</em> then keys will differ depending on the presence or absence of the <code>X-Requested-With</code> request header so <em class="italic">AJAX</em> requests will be cached separately from regular requests. This is useful when you have an action that renders different content when it is requested via <em class="italic">AJAX_.<p class="paragraph"/><h5>contentType</h5><p class="paragraph"/>If _true</em> keys will differ depending on the requested content format as determined by the <code>format</code> meta-property on <code>HttpServletRequest</code>. This is useful when you use content negotiation in a request so that responses with different formats are cached separately.<p class="paragraph"/>See <a href="../guide/single.html#4.6. Content Negotiation" class="guide">Content Negotiation</a> for more detail.<p class="paragraph"/><h5>requestMethod</h5><p class="paragraph"/>If <em class="italic">true</em> keys will differ depending on the request HTTP method. This is useful for some <em class="italic">RESTful</em> controllers (although if different request methods are mapped to different actions you do not need to use this mechanism). <em class="italic">GET</em> and <em class="italic">HEAD</em> requests are considered the same for the purposes of key generation.<p class="paragraph"/><h4>Example configuration</h4><p class="paragraph"/><div class="code"><pre>ajaxAwareKeyGenerator(WebContentKeyGenerator) &#123;
	ajax = <span class="java&#45;keyword">true</span>
&#125;<p class="paragraph"/>contentTypeAwareKeyGenerator(WebContentKeyGenerator) &#123;
	contentType = <span class="java&#45;keyword">true</span>
&#125;</pre></div><p class="paragraph"/><h2><a name="4.6. Content Negotiation">4.6. Content Negotiation</a></h2>By default the key generator used by the page fragment caching filter does not take content negotiation into account. However, if you are caching controller actions that use Grails' <a href="http://grails.org/doc/latest/ref/Controllers/withFormat.html" target="blank"><code>withFormat</code></a> dynamic method to render different content types you will want to cache results separately according to the output format. You can use the <code>WebContentKeyGenerator</code> class to do this. You just need to register a key generator bean with Spring and then annotate any content negotiated actions like this:<p class="paragraph"/><h4>grails-app/conf/spring/resources.groovy</h4><p class="paragraph"/><div class="code"><pre>mimeTypeAwareKeyGenerator(WebContentKeyGenerator) &#123;
	contentType = <span class="java&#45;keyword">true</span>
&#125;</pre></div><p class="paragraph"/><h4>grails-app/controllers/MyController.groovy</h4><p class="paragraph"/><div class="code"><pre>@Cacheable(cache = <span class="java&#45;quote">"albumControllerCache"</span>, keyGenerator = <span class="java&#45;quote">"mimeTypeAwareKeyGenerator"</span>)
def list = &#123;
    def albumList = Album.list()
	withFormat &#123;
		html &#123; &#91;albumList: albumList&#93; &#125;
		xml &#123; render albumList as XML &#125;
		json &#123; render albumList as JSON &#125;
	&#125;
&#125;</pre></div>
<h2><a name="4.7. Full Page Caching">4.7. Full Page Caching</a></h2>The plugin only provides page fragment caching rather than full page caching. Full page caching is very simple to apply using the <em class="italic">EhCache-Web</em> library that the Springcache plugin uses. See my blog post <a href="http://adhockery.blogspot.com/2010/02/full-page-caching-in-grails-with.html" target="blank">here</a> for details.
<h2><a name="4.8. TagLib Caching">4.8. TagLib Caching</a></h2>An alternative to using includes for caching smaller page fragments is to use caching on taglib tags. When a cacheable tag is called, the parameters it is called with from the cache key. If there is no entry in the cache, the tag is executed and the output that it generated is cached (as well as being written to the page). If there is an entry in the cache, the tag is not executed and the cached output is written to the page.<p class="paragraph"/><div class="code"><pre>class BlogArticlesTagLib &#123;<p class="paragraph"/>    <span class="java&#45;keyword">static</span> namespace = <span class="java&#45;quote">"blogarticles"</span><p class="paragraph"/>    def blogArticlesService<p class="paragraph"/>    @Cacheable(<span class="java&#45;quote">"blogArticlesTagCache"</span>)
    def allArticles = &#123; attrs &#45;&#62;
        out &#60;&#60; <span class="java&#45;quote">"&#60;ul&#62;"</span>
        blogArticlesService.getArticles(attrs.id).each &#123;
            out &#60;&#60; <span class="java&#45;quote">"&#60;li&#62;$&#123;it.title&#125;&#60;/li&#62;"</span>
        &#125;
        out &#60;&#60; <span class="java&#45;quote">"&#60;/ul&#62;"</span>
    &#125;
&#125;</pre></div><p class="paragraph"/>When we call the tag like soâ€¦<p class="paragraph"/><div class="code"><pre>&#60;blogarticles:allArticles id=<span class="java&#45;quote">"$&#123;blogId&#125;"</span> /&#62;</pre></div><p class="paragraph"/>The cache key is formed by the 'id' tag. This tag can be reused across different views without changing the caching semantics. That is, the controller/action that the cacheable tag is called from <strong class="bold">does not</strong> affect the cache key.<p class="paragraph"/><h3>Tags with a body</h3><p class="paragraph"/>When caching a tag with a body, if there is a cache hit the body will not be executed. Therefore it doesn't make sense to cache a tag that is invoked with a different body unless you are ensuring the right cacheability through the tag parameters (i.e. cache keys).
    </body>
</html>
